/**
Copyright (c) 2012-2020, Brice Videau <bvideau@anl.gov>
Copyright (c) 2012-2020, Vincent Danjean <Vincent.Danjean@ens-lyon.org>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Do not edit this file. It is automatically generated.

*/
#include <stdio.h>
#include <string.h>
#define CL_USE_DEPRECATED_OPENCL_1_0_APIS
#define CL_USE_DEPRECATED_OPENCL_1_1_APIS
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#define CL_USE_DEPRECATED_OPENCL_2_0_APIS
#define CL_USE_DEPRECATED_OPENCL_2_1_APIS
#define CL_USE_DEPRECATED_OPENCL_2_2_APIS
#define CL_TARGET_OPENCL_VERSION 300
#ifdef HAVE_OPENCL_CL_LAYER_H
#include <OpenCL/cl_layer.h>
#elif defined HAVE_CL_CL_LAYER_H
#include <CL/cl_layer.h>
#else
#include "khronos-headers/CL/cl_layer.h"
#endif

static struct _cl_icd_dispatch dispatch = {NULL};
static const struct _cl_icd_dispatch *tdispatch;
static const cl_layer_api_version layer_api_version = CL_LAYER_API_VERSION_100;
static const char layer_name[] = "dummylayer";

CL_API_ENTRY cl_int CL_API_CALL
clGetLayerInfo(
    cl_layer_info  param_name,
    size_t         param_value_size,
    void          *param_value,
    size_t        *param_value_size_ret) {
  size_t sz = 0;
  const void *src = NULL;
  if (param_value_size && !param_value)
    return CL_INVALID_VALUE;
  if (!param_value && !param_value_size_ret)
    return CL_INVALID_VALUE;
  switch (param_name) {
  case CL_LAYER_API_VERSION:
    sz = sizeof(cl_layer_api_version);
    src = &layer_api_version;
    break;
  case CL_LAYER_NAME:
    sz = sizeof(layer_name);
    src = layer_name;
    break;
  default:
    return CL_INVALID_VALUE;
  }
  if (param_value && param_value_size < sz)
    return CL_INVALID_VALUE;
  if (param_value)
    memcpy(param_value, src, sz);
  if (param_value_size_ret)
    *param_value_size_ret = sz;
  return CL_SUCCESS;
}

static void _init_dispatch(void);

CL_API_ENTRY cl_int CL_API_CALL
clInitLayer(
    cl_uint                         num_entries,
    const struct _cl_icd_dispatch  *target_dispatch,
    cl_uint                        *num_entries_out,
    const struct _cl_icd_dispatch **layer_dispatch) {
  if (!target_dispatch || !layer_dispatch ||!num_entries_out || num_entries < sizeof(dispatch)/sizeof(dispatch.clGetPlatformIDs))
    return -1;

  _init_dispatch();

  tdispatch = target_dispatch;
  *layer_dispatch = &dispatch;
  *num_entries_out = sizeof(dispatch)/sizeof(dispatch.clGetPlatformIDs);
  return CL_SUCCESS;
}

static  cl_int 
clGetPlatformIDs_wrap(cl_uint           num_entries ,
                 cl_platform_id *  platforms ,
                 cl_uint *         num_platforms ){
  printf("clGetPlatformIDs\n");
  return tdispatch->clGetPlatformIDs(num_entries, platforms, num_platforms);
}

static  cl_int  
clGetPlatformInfo_wrap(cl_platform_id    platform , 
                  cl_platform_info  param_name ,
                  size_t            param_value_size , 
                  void *            param_value ,
                  size_t *          param_value_size_ret ){
  printf("clGetPlatformInfo\n");
  return tdispatch->clGetPlatformInfo(platform, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clGetDeviceIDs_wrap(cl_platform_id    platform ,
               cl_device_type    device_type , 
               cl_uint           num_entries , 
               cl_device_id *    devices , 
               cl_uint *         num_devices ){
  printf("clGetDeviceIDs\n");
  return tdispatch->clGetDeviceIDs(platform, device_type, num_entries, devices, num_devices);
}

static  cl_int 
clGetDeviceInfo_wrap(cl_device_id     device ,
                cl_device_info   param_name , 
                size_t           param_value_size , 
                void *           param_value ,
                size_t *         param_value_size_ret ){
  printf("clGetDeviceInfo\n");
  return tdispatch->clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_context 
clCreateContext_wrap(const cl_context_properties *  properties ,
                cl_uint                        num_devices ,
                const cl_device_id *           devices ,
                void (CL_CALLBACK *  pfn_notify )(const char *, const void *, size_t, void *),
                void *                         user_data ,
                cl_int *                       errcode_ret ){
  printf("clCreateContext\n");
  return tdispatch->clCreateContext(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
}

static  cl_context 
clCreateContextFromType_wrap(const cl_context_properties *  properties ,
                        cl_device_type                 device_type ,
                        void (CL_CALLBACK *      pfn_notify )(const char *, const void *, size_t, void *),
                        void *                         user_data ,
                        cl_int *                       errcode_ret ){
  printf("clCreateContextFromType\n");
  return tdispatch->clCreateContextFromType(properties, device_type, pfn_notify, user_data, errcode_ret);
}

static  cl_int 
clRetainContext_wrap(cl_context  context ){
  printf("clRetainContext\n");
  return tdispatch->clRetainContext(context);
}

static  cl_int 
clReleaseContext_wrap(cl_context  context ){
  printf("clReleaseContext\n");
  return tdispatch->clReleaseContext(context);
}

static  cl_int 
clGetContextInfo_wrap(cl_context          context , 
                 cl_context_info     param_name , 
                 size_t              param_value_size , 
                 void *              param_value , 
                 size_t *            param_value_size_ret ){
  printf("clGetContextInfo\n");
  return tdispatch->clGetContextInfo(context, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_command_queue 
clCreateCommandQueue_wrap(cl_context                      context , 
                     cl_device_id                    device , 
                     cl_command_queue_properties     properties ,
                     cl_int *                        errcode_ret ){
  printf("clCreateCommandQueue\n");
  return tdispatch->clCreateCommandQueue(context, device, properties, errcode_ret);
}

static  cl_int 
clRetainCommandQueue_wrap(cl_command_queue  command_queue ){
  printf("clRetainCommandQueue\n");
  return tdispatch->clRetainCommandQueue(command_queue);
}

static  cl_int 
clReleaseCommandQueue_wrap(cl_command_queue  command_queue ){
  printf("clReleaseCommandQueue\n");
  return tdispatch->clReleaseCommandQueue(command_queue);
}

static  cl_int 
clGetCommandQueueInfo_wrap(cl_command_queue       command_queue ,
                      cl_command_queue_info  param_name ,
                      size_t                 param_value_size ,
                      void *                 param_value ,
                      size_t *               param_value_size_ret ){
  printf("clGetCommandQueueInfo\n");
  return tdispatch->clGetCommandQueueInfo(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clSetCommandQueueProperty_wrap(cl_command_queue               command_queue ,
                          cl_command_queue_properties    properties , 
                          cl_bool                         enable ,
                          cl_command_queue_properties *  old_properties ){
  printf("clSetCommandQueueProperty\n");
  return tdispatch->clSetCommandQueueProperty(command_queue, properties, enable, old_properties);
}

static  cl_mem 
clCreateBuffer_wrap(cl_context    context ,
               cl_mem_flags  flags ,
               size_t        size ,
               void *        host_ptr ,
               cl_int *      errcode_ret ){
  printf("clCreateBuffer\n");
  return tdispatch->clCreateBuffer(context, flags, size, host_ptr, errcode_ret);
}

static  cl_mem 
clCreateImage2D_wrap(cl_context               context ,
                cl_mem_flags             flags ,
                const cl_image_format *  image_format ,
                size_t                   image_width ,
                size_t                   image_height ,
                size_t                   image_row_pitch , 
                void *                   host_ptr ,
                cl_int *                 errcode_ret ){
  printf("clCreateImage2D\n");
  return tdispatch->clCreateImage2D(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
}

static  cl_mem 
clCreateImage3D_wrap(cl_context               context ,
                cl_mem_flags             flags ,
                const cl_image_format *  image_format ,
                size_t                   image_width , 
                size_t                   image_height ,
                size_t                   image_depth , 
                size_t                   image_row_pitch , 
                size_t                   image_slice_pitch , 
                void *                   host_ptr ,
                cl_int *                 errcode_ret ){
  printf("clCreateImage3D\n");
  return tdispatch->clCreateImage3D(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
}

static  cl_int 
clRetainMemObject_wrap(cl_mem  memobj ){
  printf("clRetainMemObject\n");
  return tdispatch->clRetainMemObject(memobj);
}

static  cl_int 
clReleaseMemObject_wrap(cl_mem  memobj ){
  printf("clReleaseMemObject\n");
  return tdispatch->clReleaseMemObject(memobj);
}

static  cl_int 
clGetSupportedImageFormats_wrap(cl_context            context ,
                           cl_mem_flags          flags ,
                           cl_mem_object_type    image_type ,
                           cl_uint               num_entries ,
                           cl_image_format *     image_formats ,
                           cl_uint *             num_image_formats ){
  printf("clGetSupportedImageFormats\n");
  return tdispatch->clGetSupportedImageFormats(context, flags, image_type, num_entries, image_formats, num_image_formats);
}

static  cl_int 
clGetMemObjectInfo_wrap(cl_mem            memobj ,
                   cl_mem_info       param_name , 
                   size_t            param_value_size ,
                   void *            param_value ,
                   size_t *          param_value_size_ret ){
  printf("clGetMemObjectInfo\n");
  return tdispatch->clGetMemObjectInfo(memobj, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clGetImageInfo_wrap(cl_mem            image ,
               cl_image_info     param_name , 
               size_t            param_value_size ,
               void *            param_value ,
               size_t *          param_value_size_ret ){
  printf("clGetImageInfo\n");
  return tdispatch->clGetImageInfo(image, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_sampler 
clCreateSampler_wrap(cl_context           context ,
                cl_bool              normalized_coords , 
                cl_addressing_mode   addressing_mode , 
                cl_filter_mode       filter_mode ,
                cl_int *             errcode_ret ){
  printf("clCreateSampler\n");
  return tdispatch->clCreateSampler(context, normalized_coords, addressing_mode, filter_mode, errcode_ret);
}

static  cl_int 
clRetainSampler_wrap(cl_sampler  sampler ){
  printf("clRetainSampler\n");
  return tdispatch->clRetainSampler(sampler);
}

static  cl_int 
clReleaseSampler_wrap(cl_sampler  sampler ){
  printf("clReleaseSampler\n");
  return tdispatch->clReleaseSampler(sampler);
}

static  cl_int 
clGetSamplerInfo_wrap(cl_sampler          sampler ,
                 cl_sampler_info     param_name ,
                 size_t              param_value_size ,
                 void *              param_value ,
                 size_t *            param_value_size_ret ){
  printf("clGetSamplerInfo\n");
  return tdispatch->clGetSamplerInfo(sampler, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_program 
clCreateProgramWithSource_wrap(cl_context         context ,
                          cl_uint            count ,
                          const char **      strings ,
                          const size_t *     lengths ,
                          cl_int *           errcode_ret ){
  printf("clCreateProgramWithSource\n");
  return tdispatch->clCreateProgramWithSource(context, count, strings, lengths, errcode_ret);
}

static  cl_program 
clCreateProgramWithBinary_wrap(cl_context                      context ,
                          cl_uint                         num_devices ,
                          const cl_device_id *            device_list ,
                          const size_t *                  lengths ,
                          const unsigned char **          binaries ,
                          cl_int *                        binary_status ,
                          cl_int *                        errcode_ret ){
  printf("clCreateProgramWithBinary\n");
  return tdispatch->clCreateProgramWithBinary(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
}

static  cl_int 
clRetainProgram_wrap(cl_program  program ){
  printf("clRetainProgram\n");
  return tdispatch->clRetainProgram(program);
}

static  cl_int 
clReleaseProgram_wrap(cl_program  program ){
  printf("clReleaseProgram\n");
  return tdispatch->clReleaseProgram(program);
}

static  cl_int 
clBuildProgram_wrap(cl_program            program ,
               cl_uint               num_devices ,
               const cl_device_id *  device_list ,
               const char *          options , 
               void (CL_CALLBACK *   pfn_notify )(cl_program  program , void *  user_data ),
               void *                user_data ){
  printf("clBuildProgram\n");
  return tdispatch->clBuildProgram(program, num_devices, device_list, options, pfn_notify, user_data);
}

static  cl_int 
clUnloadCompiler_wrap( void ){
  printf("clUnloadCompiler\n");
  return tdispatch->clUnloadCompiler();
}

static  cl_int 
clGetProgramInfo_wrap(cl_program          program ,
                 cl_program_info     param_name ,
                 size_t              param_value_size ,
                 void *              param_value ,
                 size_t *            param_value_size_ret ){
  printf("clGetProgramInfo\n");
  return tdispatch->clGetProgramInfo(program, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clGetProgramBuildInfo_wrap(cl_program             program ,
                      cl_device_id           device ,
                      cl_program_build_info  param_name ,
                      size_t                 param_value_size ,
                      void *                 param_value ,
                      size_t *               param_value_size_ret ){
  printf("clGetProgramBuildInfo\n");
  return tdispatch->clGetProgramBuildInfo(program, device, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_kernel 
clCreateKernel_wrap(cl_program       program ,
               const char *     kernel_name ,
               cl_int *         errcode_ret ){
  printf("clCreateKernel\n");
  return tdispatch->clCreateKernel(program, kernel_name, errcode_ret);
}

static  cl_int 
clCreateKernelsInProgram_wrap(cl_program      program ,
                         cl_uint         num_kernels ,
                         cl_kernel *     kernels ,
                         cl_uint *       num_kernels_ret ){
  printf("clCreateKernelsInProgram\n");
  return tdispatch->clCreateKernelsInProgram(program, num_kernels, kernels, num_kernels_ret);
}

static  cl_int 
clRetainKernel_wrap(cl_kernel     kernel ){
  printf("clRetainKernel\n");
  return tdispatch->clRetainKernel(kernel);
}

static  cl_int 
clReleaseKernel_wrap(cl_kernel    kernel ){
  printf("clReleaseKernel\n");
  return tdispatch->clReleaseKernel(kernel);
}

static  cl_int 
clSetKernelArg_wrap(cl_kernel     kernel ,
               cl_uint       arg_index ,
               size_t        arg_size ,
               const void *  arg_value ){
  printf("clSetKernelArg\n");
  return tdispatch->clSetKernelArg(kernel, arg_index, arg_size, arg_value);
}

static  cl_int 
clGetKernelInfo_wrap(cl_kernel        kernel ,
                cl_kernel_info   param_name ,
                size_t           param_value_size ,
                void *           param_value ,
                size_t *         param_value_size_ret ){
  printf("clGetKernelInfo\n");
  return tdispatch->clGetKernelInfo(kernel, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clGetKernelWorkGroupInfo_wrap(cl_kernel                   kernel ,
                         cl_device_id                device ,
                         cl_kernel_work_group_info   param_name ,
                         size_t                      param_value_size ,
                         void *                      param_value ,
                         size_t *                    param_value_size_ret ){
  printf("clGetKernelWorkGroupInfo\n");
  return tdispatch->clGetKernelWorkGroupInfo(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clWaitForEvents_wrap(cl_uint              num_events ,
                const cl_event *     event_list ){
  printf("clWaitForEvents\n");
  return tdispatch->clWaitForEvents(num_events, event_list);
}

static  cl_int 
clGetEventInfo_wrap(cl_event          event ,
               cl_event_info     param_name ,
               size_t            param_value_size ,
               void *            param_value ,
               size_t *          param_value_size_ret ){
  printf("clGetEventInfo\n");
  return tdispatch->clGetEventInfo(event, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clRetainEvent_wrap(cl_event  event ){
  printf("clRetainEvent\n");
  return tdispatch->clRetainEvent(event);
}

static  cl_int 
clReleaseEvent_wrap(cl_event  event ){
  printf("clReleaseEvent\n");
  return tdispatch->clReleaseEvent(event);
}

static  cl_int 
clGetEventProfilingInfo_wrap(cl_event             event ,
                        cl_profiling_info    param_name ,
                        size_t               param_value_size ,
                        void *               param_value ,
                        size_t *             param_value_size_ret ){
  printf("clGetEventProfilingInfo\n");
  return tdispatch->clGetEventProfilingInfo(event, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clFlush_wrap(cl_command_queue  command_queue ){
  printf("clFlush\n");
  return tdispatch->clFlush(command_queue);
}

static  cl_int 
clFinish_wrap(cl_command_queue  command_queue ){
  printf("clFinish\n");
  return tdispatch->clFinish(command_queue);
}

static  cl_int 
clEnqueueReadBuffer_wrap(cl_command_queue     command_queue ,
                    cl_mem               buffer ,
                    cl_bool              blocking_read ,
                    size_t               offset ,
                    size_t               cb , 
                    void *               ptr ,
                    cl_uint              num_events_in_wait_list ,
                    const cl_event *     event_wait_list ,
                    cl_event *           event ){
  printf("clEnqueueReadBuffer\n");
  return tdispatch->clEnqueueReadBuffer(command_queue, buffer, blocking_read, offset, cb, ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueWriteBuffer_wrap(cl_command_queue    command_queue , 
                     cl_mem              buffer , 
                     cl_bool             blocking_write , 
                     size_t              offset , 
                     size_t              cb , 
                     const void *        ptr , 
                     cl_uint             num_events_in_wait_list , 
                     const cl_event *    event_wait_list , 
                     cl_event *          event ){
  printf("clEnqueueWriteBuffer\n");
  return tdispatch->clEnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, cb, ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueCopyBuffer_wrap(cl_command_queue     command_queue , 
                    cl_mem               src_buffer ,
                    cl_mem               dst_buffer , 
                    size_t               src_offset ,
                    size_t               dst_offset ,
                    size_t               cb , 
                    cl_uint              num_events_in_wait_list ,
                    const cl_event *     event_wait_list ,
                    cl_event *           event ){
  printf("clEnqueueCopyBuffer\n");
  return tdispatch->clEnqueueCopyBuffer(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, cb, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueReadImage_wrap(cl_command_queue      command_queue ,
                   cl_mem                image ,
                   cl_bool               blocking_read , 
                   const size_t *        origin ,
                   const size_t *        region ,
                   size_t                row_pitch ,
                   size_t                slice_pitch , 
                   void *                ptr ,
                   cl_uint               num_events_in_wait_list ,
                   const cl_event *      event_wait_list ,
                   cl_event *            event ){
  printf("clEnqueueReadImage\n");
  return tdispatch->clEnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueWriteImage_wrap(cl_command_queue     command_queue ,
                    cl_mem               image ,
                    cl_bool              blocking_write , 
                    const size_t *       origin ,
                    const size_t *       region ,
                    size_t               input_row_pitch ,
                    size_t               input_slice_pitch , 
                    const void *         ptr ,
                    cl_uint              num_events_in_wait_list ,
                    const cl_event *     event_wait_list ,
                    cl_event *           event ){
  printf("clEnqueueWriteImage\n");
  return tdispatch->clEnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueCopyImage_wrap(cl_command_queue      command_queue ,
                   cl_mem                src_image ,
                   cl_mem                dst_image , 
                   const size_t *        src_origin ,
                   const size_t *        dst_origin ,
                   const size_t *        region , 
                   cl_uint               num_events_in_wait_list ,
                   const cl_event *      event_wait_list ,
                   cl_event *            event ){
  printf("clEnqueueCopyImage\n");
  return tdispatch->clEnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueCopyImageToBuffer_wrap(cl_command_queue  command_queue ,
                           cl_mem            src_image ,
                           cl_mem            dst_buffer , 
                           const size_t *    src_origin ,
                           const size_t *    region , 
                           size_t            dst_offset ,
                           cl_uint           num_events_in_wait_list ,
                           const cl_event *  event_wait_list ,
                           cl_event *        event ){
  printf("clEnqueueCopyImageToBuffer\n");
  return tdispatch->clEnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueCopyBufferToImage_wrap(cl_command_queue  command_queue ,
                           cl_mem            src_buffer ,
                           cl_mem            dst_image , 
                           size_t            src_offset ,
                           const size_t *    dst_origin ,
                           const size_t *    region , 
                           cl_uint           num_events_in_wait_list ,
                           const cl_event *  event_wait_list ,
                           cl_event *        event ){
  printf("clEnqueueCopyBufferToImage\n");
  return tdispatch->clEnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
}

static  void * 
clEnqueueMapBuffer_wrap(cl_command_queue  command_queue ,
                   cl_mem            buffer ,
                   cl_bool           blocking_map , 
                   cl_map_flags      map_flags ,
                   size_t            offset ,
                   size_t            cb ,
                   cl_uint           num_events_in_wait_list ,
                   const cl_event *  event_wait_list ,
                   cl_event *        event ,
                   cl_int *          errcode_ret ){
  printf("clEnqueueMapBuffer\n");
  return tdispatch->clEnqueueMapBuffer(command_queue, buffer, blocking_map, map_flags, offset, cb, num_events_in_wait_list, event_wait_list, event, errcode_ret);
}

static  void * 
clEnqueueMapImage_wrap(cl_command_queue   command_queue ,
                  cl_mem             image , 
                  cl_bool            blocking_map , 
                  cl_map_flags       map_flags , 
                  const size_t *     origin ,
                  const size_t *     region ,
                  size_t *           image_row_pitch ,
                  size_t *           image_slice_pitch ,
                  cl_uint            num_events_in_wait_list ,
                  const cl_event *   event_wait_list ,
                  cl_event *         event ,
                  cl_int *           errcode_ret ){
  printf("clEnqueueMapImage\n");
  return tdispatch->clEnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, event, errcode_ret);
}

static  cl_int 
clEnqueueUnmapMemObject_wrap(cl_command_queue  command_queue ,
                        cl_mem            memobj ,
                        void *            mapped_ptr ,
                        cl_uint           num_events_in_wait_list ,
                        const cl_event *   event_wait_list ,
                        cl_event *         event ){
  printf("clEnqueueUnmapMemObject\n");
  return tdispatch->clEnqueueUnmapMemObject(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueNDRangeKernel_wrap(cl_command_queue  command_queue ,
                       cl_kernel         kernel ,
                       cl_uint           work_dim ,
                       const size_t *    global_work_offset ,
                       const size_t *    global_work_size ,
                       const size_t *    local_work_size ,
                       cl_uint           num_events_in_wait_list ,
                       const cl_event *  event_wait_list ,
                       cl_event *        event ){
  printf("clEnqueueNDRangeKernel\n");
  return tdispatch->clEnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueTask_wrap(cl_command_queue   command_queue ,
              cl_kernel          kernel ,
              cl_uint            num_events_in_wait_list ,
              const cl_event *   event_wait_list ,
              cl_event *         event ){
  printf("clEnqueueTask\n");
  return tdispatch->clEnqueueTask(command_queue, kernel, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueNativeKernel_wrap(cl_command_queue   command_queue ,
					  void (*user_func)(void *), 
                      void *             args ,
                      size_t             cb_args , 
                      cl_uint            num_mem_objects ,
                      const cl_mem *     mem_list ,
                      const void **      args_mem_loc ,
                      cl_uint            num_events_in_wait_list ,
                      const cl_event *   event_wait_list ,
                      cl_event *         event ){
  printf("clEnqueueNativeKernel\n");
  return tdispatch->clEnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueMarker_wrap(cl_command_queue     command_queue ,
                cl_event *           event ){
  printf("clEnqueueMarker\n");
  return tdispatch->clEnqueueMarker(command_queue, event);
}

static  cl_int 
clEnqueueWaitForEvents_wrap(cl_command_queue  command_queue ,
                       cl_uint           num_events ,
                       const cl_event *  event_list ){
  printf("clEnqueueWaitForEvents\n");
  return tdispatch->clEnqueueWaitForEvents(command_queue, num_events, event_list);
}

static  cl_int 
clEnqueueBarrier_wrap(cl_command_queue  command_queue ){
  printf("clEnqueueBarrier\n");
  return tdispatch->clEnqueueBarrier(command_queue);
}

static  void * 
clGetExtensionFunctionAddress_wrap(const char *  func_name ){
  printf("clGetExtensionFunctionAddress\n");
  return tdispatch->clGetExtensionFunctionAddress(func_name);
}

static  cl_mem 
clCreateFromGLBuffer_wrap(cl_context      context ,
                     cl_mem_flags    flags ,
                     cl_GLuint       bufobj ,
                     int *           errcode_ret ){
  printf("clCreateFromGLBuffer\n");
  return tdispatch->clCreateFromGLBuffer(context, flags, bufobj, errcode_ret);
}

static  cl_mem 
clCreateFromGLTexture2D_wrap(cl_context       context ,
                        cl_mem_flags     flags ,
                        cl_GLenum        target ,
                        cl_GLint         miplevel ,
                        cl_GLuint        texture ,
                        cl_int *         errcode_ret ){
  printf("clCreateFromGLTexture2D\n");
  return tdispatch->clCreateFromGLTexture2D(context, flags, target, miplevel, texture, errcode_ret);
}

static  cl_mem 
clCreateFromGLTexture3D_wrap(cl_context       context ,
                        cl_mem_flags     flags ,
                        cl_GLenum        target ,
                        cl_GLint         miplevel ,
                        cl_GLuint        texture ,
                        cl_int *         errcode_ret ){
  printf("clCreateFromGLTexture3D\n");
  return tdispatch->clCreateFromGLTexture3D(context, flags, target, miplevel, texture, errcode_ret);
}

static  cl_mem 
clCreateFromGLRenderbuffer_wrap(cl_context    context ,
                           cl_mem_flags  flags ,
                           cl_GLuint     renderbuffer ,
                           cl_int *      errcode_ret ){
  printf("clCreateFromGLRenderbuffer\n");
  return tdispatch->clCreateFromGLRenderbuffer(context, flags, renderbuffer, errcode_ret);
}

static  cl_int 
clGetGLObjectInfo_wrap(cl_mem                 memobj ,
                  cl_gl_object_type *    gl_object_type ,
                  cl_GLuint *               gl_object_name ){
  printf("clGetGLObjectInfo\n");
  return tdispatch->clGetGLObjectInfo(memobj, gl_object_type, gl_object_name);
}

static  cl_int 
clGetGLTextureInfo_wrap(cl_mem                memobj ,
                   cl_gl_texture_info    param_name ,
                   size_t                param_value_size ,
                   void *                param_value ,
                   size_t *              param_value_size_ret ){
  printf("clGetGLTextureInfo\n");
  return tdispatch->clGetGLTextureInfo(memobj, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clEnqueueAcquireGLObjects_wrap(cl_command_queue       command_queue ,
                          cl_uint                num_objects ,
                          const cl_mem *         mem_objects ,
                          cl_uint                num_events_in_wait_list ,
                          const cl_event *       event_wait_list ,
                          cl_event *             event ){
  printf("clEnqueueAcquireGLObjects\n");
  return tdispatch->clEnqueueAcquireGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueReleaseGLObjects_wrap(cl_command_queue       command_queue ,
                          cl_uint                num_objects ,
                          const cl_mem *         mem_objects ,
                          cl_uint                num_events_in_wait_list ,
                          const cl_event *       event_wait_list ,
                          cl_event *             event ){
  printf("clEnqueueReleaseGLObjects\n");
  return tdispatch->clEnqueueReleaseGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clGetGLContextInfoKHR_wrap(const cl_context_properties *  properties ,
                      cl_gl_context_info             param_name ,
                      size_t                         param_value_size ,
                      void *                         param_value ,
                      size_t *                       param_value_size_ret ){
  printf("clGetGLContextInfoKHR\n");
  return tdispatch->clGetGLContextInfoKHR(properties, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clSetEventCallback_wrap(cl_event     event ,
                   cl_int       command_exec_callback_type ,
                   void (CL_CALLBACK *  pfn_notify )(cl_event, cl_int, void *),
                   void *       user_data ){
  printf("clSetEventCallback\n");
  return tdispatch->clSetEventCallback(event, command_exec_callback_type, pfn_notify, user_data);
}

static  cl_mem 
clCreateSubBuffer_wrap(cl_mem                    buffer ,
                  cl_mem_flags              flags ,
                  cl_buffer_create_type     buffer_create_type ,
                  const void *              buffer_create_info ,
                  cl_int *                  errcode_ret ){
  printf("clCreateSubBuffer\n");
  return tdispatch->clCreateSubBuffer(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
}

static  cl_int 
clSetMemObjectDestructorCallback_wrap(cl_mem  memobj ,
                                 void (CL_CALLBACK * pfn_notify)( cl_mem  memobj , void* user_data),
                                 void * user_data  ){
  printf("clSetMemObjectDestructorCallback\n");
  return tdispatch->clSetMemObjectDestructorCallback(memobj, pfn_notify, user_data);
}

static  cl_event 
clCreateUserEvent_wrap(cl_context     context ,
                  cl_int *       errcode_ret ){
  printf("clCreateUserEvent\n");
  return tdispatch->clCreateUserEvent(context, errcode_ret);
}

static  cl_int 
clSetUserEventStatus_wrap(cl_event    event ,
                     cl_int      execution_status ){
  printf("clSetUserEventStatus\n");
  return tdispatch->clSetUserEventStatus(event, execution_status);
}

static  cl_int 
clEnqueueReadBufferRect_wrap(cl_command_queue     command_queue ,
                        cl_mem               buffer ,
                        cl_bool              blocking_read ,
                        const size_t *       buffer_origin ,
                        const size_t *       host_origin , 
                        const size_t *       region ,
                        size_t               buffer_row_pitch ,
                        size_t               buffer_slice_pitch ,
                        size_t               host_row_pitch ,
                        size_t               host_slice_pitch ,                        
                        void *               ptr ,
                        cl_uint              num_events_in_wait_list ,
                        const cl_event *     event_wait_list ,
                        cl_event *           event ){
  printf("clEnqueueReadBufferRect\n");
  return tdispatch->clEnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueWriteBufferRect_wrap(cl_command_queue     command_queue ,
                         cl_mem               buffer ,
                         cl_bool              blocking_write ,
                         const size_t *       buffer_origin ,
                         const size_t *       host_origin , 
                         const size_t *       region ,
                         size_t               buffer_row_pitch ,
                         size_t               buffer_slice_pitch ,
                         size_t               host_row_pitch ,
                         size_t               host_slice_pitch ,                        
                         const void *         ptr ,
                         cl_uint              num_events_in_wait_list ,
                         const cl_event *     event_wait_list ,
                         cl_event *           event ){
  printf("clEnqueueWriteBufferRect\n");
  return tdispatch->clEnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueCopyBufferRect_wrap(cl_command_queue     command_queue , 
                        cl_mem               src_buffer ,
                        cl_mem               dst_buffer , 
                        const size_t *       src_origin ,
                        const size_t *       dst_origin ,
                        const size_t *       region , 
                        size_t               src_row_pitch ,
                        size_t               src_slice_pitch ,
                        size_t               dst_row_pitch ,
                        size_t               dst_slice_pitch ,
                        cl_uint              num_events_in_wait_list ,
                        const cl_event *     event_wait_list ,
                        cl_event *           event ){
  printf("clEnqueueCopyBufferRect\n");
  return tdispatch->clEnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clCreateSubDevicesEXT_wrap(cl_device_id in_device,
                      const cl_device_partition_property_ext *  properties ,
                      cl_uint num_entries,
                      cl_device_id * out_devices,
                      cl_uint * num_devices ){
  printf("clCreateSubDevicesEXT\n");
  return tdispatch->clCreateSubDevicesEXT(in_device, properties, num_entries, out_devices, num_devices);
}

static  cl_int 
clRetainDeviceEXT_wrap( cl_device_id device ){
  printf("clRetainDeviceEXT\n");
  return tdispatch->clRetainDeviceEXT(device);
}

static  cl_int 
clReleaseDeviceEXT_wrap( cl_device_id device ){
  printf("clReleaseDeviceEXT\n");
  return tdispatch->clReleaseDeviceEXT(device);
}

static  cl_event 
clCreateEventFromGLsyncKHR_wrap(cl_context            context ,
                           cl_GLsync             cl_GLsync ,
                           cl_int *              errcode_ret ){
  printf("clCreateEventFromGLsyncKHR\n");
  return tdispatch->clCreateEventFromGLsyncKHR(context, cl_GLsync, errcode_ret);
}

static  cl_int 
clCreateSubDevices_wrap(cl_device_id                          in_device ,
                   const cl_device_partition_property *  properties ,
                   cl_uint                               num_devices ,
                   cl_device_id *                        out_devices ,
                   cl_uint *                             num_devices_ret ){
  printf("clCreateSubDevices\n");
  return tdispatch->clCreateSubDevices(in_device, properties, num_devices, out_devices, num_devices_ret);
}

static  cl_int 
clRetainDevice_wrap(cl_device_id  device ){
  printf("clRetainDevice\n");
  return tdispatch->clRetainDevice(device);
}

static  cl_int 
clReleaseDevice_wrap(cl_device_id  device ){
  printf("clReleaseDevice\n");
  return tdispatch->clReleaseDevice(device);
}

static  cl_mem 
clCreateImage_wrap(cl_context               context ,
              cl_mem_flags             flags ,
              const cl_image_format *  image_format ,
              const cl_image_desc *    image_desc , 
              void *                   host_ptr ,
              cl_int *                 errcode_ret ){
  printf("clCreateImage\n");
  return tdispatch->clCreateImage(context, flags, image_format, image_desc, host_ptr, errcode_ret);
}

static  cl_program 
clCreateProgramWithBuiltInKernels_wrap(cl_context             context ,
                                  cl_uint                num_devices ,
                                  const cl_device_id *   device_list ,
                                  const char *           kernel_names ,
                                  cl_int *               errcode_ret ){
  printf("clCreateProgramWithBuiltInKernels\n");
  return tdispatch->clCreateProgramWithBuiltInKernels(context, num_devices, device_list, kernel_names, errcode_ret);
}

static  cl_int 
clCompileProgram_wrap(cl_program            program ,
                 cl_uint               num_devices ,
                 const cl_device_id *  device_list ,
                 const char *          options , 
                 cl_uint               num_input_headers ,
                 const cl_program *    input_headers ,
                 const char **         header_include_names ,
                 void (CL_CALLBACK *   pfn_notify )(cl_program  program , void *  user_data ),
                 void *                user_data ){
  printf("clCompileProgram\n");
  return tdispatch->clCompileProgram(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
}

static  cl_program 
clLinkProgram_wrap(cl_context            context ,
              cl_uint               num_devices ,
              const cl_device_id *  device_list ,
              const char *          options , 
              cl_uint               num_input_programs ,
              const cl_program *    input_programs ,
              void (CL_CALLBACK *   pfn_notify )(cl_program  program , void *  user_data ),
              void *                user_data ,
              cl_int *              errcode_ret  ){
  printf("clLinkProgram\n");
  return tdispatch->clLinkProgram(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
}

static  cl_int 
clUnloadPlatformCompiler_wrap(cl_platform_id  platform ){
  printf("clUnloadPlatformCompiler\n");
  return tdispatch->clUnloadPlatformCompiler(platform);
}

static  cl_int 
clGetKernelArgInfo_wrap(cl_kernel        kernel ,
                   cl_uint          arg_indx ,
                   cl_kernel_arg_info   param_name ,
                   size_t           param_value_size ,
                   void *           param_value ,
                   size_t *         param_value_size_ret ){
  printf("clGetKernelArgInfo\n");
  return tdispatch->clGetKernelArgInfo(kernel, arg_indx, param_name, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clEnqueueFillBuffer_wrap(cl_command_queue    command_queue ,
                    cl_mem              buffer , 
                    const void *        pattern , 
                    size_t              pattern_size , 
                    size_t              offset , 
                    size_t              size , 
                    cl_uint             num_events_in_wait_list , 
                    const cl_event *    event_wait_list , 
                    cl_event *          event ){
  printf("clEnqueueFillBuffer\n");
  return tdispatch->clEnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueFillImage_wrap(cl_command_queue    command_queue ,
                   cl_mem              image , 
                   const void *        fill_color , 
                   const size_t *      origin , 
                   const size_t *      region , 
                   cl_uint             num_events_in_wait_list , 
                   const cl_event *    event_wait_list , 
                   cl_event *          event ){
  printf("clEnqueueFillImage\n");
  return tdispatch->clEnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueMigrateMemObjects_wrap(cl_command_queue        command_queue ,
                           cl_uint                 num_mem_objects ,
                           const cl_mem *          mem_objects ,
                           cl_mem_migration_flags  flags ,
                           cl_uint                 num_events_in_wait_list ,
                           const cl_event *        event_wait_list ,
                           cl_event *              event ){
  printf("clEnqueueMigrateMemObjects\n");
  return tdispatch->clEnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueMarkerWithWaitList_wrap(cl_command_queue  command_queue ,
                            cl_uint            num_events_in_wait_list ,
                            const cl_event *   event_wait_list ,
                            cl_event *         event ){
  printf("clEnqueueMarkerWithWaitList\n");
  return tdispatch->clEnqueueMarkerWithWaitList(command_queue, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueBarrierWithWaitList_wrap(cl_command_queue  command_queue ,
                             cl_uint            num_events_in_wait_list ,
                             const cl_event *   event_wait_list ,
                             cl_event *         event ){
  printf("clEnqueueBarrierWithWaitList\n");
  return tdispatch->clEnqueueBarrierWithWaitList(command_queue, num_events_in_wait_list, event_wait_list, event);
}

static  void *  
clGetExtensionFunctionAddressForPlatform_wrap(cl_platform_id  platform ,
                                         const char *    func_name ){
  printf("clGetExtensionFunctionAddressForPlatform\n");
  return tdispatch->clGetExtensionFunctionAddressForPlatform(platform, func_name);
}

static  cl_mem 
clCreateFromGLTexture_wrap(cl_context       context ,
                      cl_mem_flags     flags ,
                      cl_GLenum        target ,
                      cl_GLint         miplevel ,
                      cl_GLuint        texture ,
                      cl_int *         errcode_ret ){
  printf("clCreateFromGLTexture\n");
  return tdispatch->clCreateFromGLTexture(context, flags, target, miplevel, texture, errcode_ret);
}

static  cl_mem 
clCreateFromEGLImageKHR_wrap(cl_context                   context ,
                        CLeglDisplayKHR              egldisplay ,
                        CLeglImageKHR                eglimage ,
                        cl_mem_flags                 flags ,
                        const cl_egl_image_properties_khr *  properties ,
                        cl_int *                     errcode_ret ){
  printf("clCreateFromEGLImageKHR\n");
  return tdispatch->clCreateFromEGLImageKHR(context, egldisplay, eglimage, flags, properties, errcode_ret);
}

static  cl_int 
clEnqueueAcquireEGLObjectsKHR_wrap(cl_command_queue  command_queue ,
                              cl_uint           num_objects ,
                              const cl_mem *    mem_objects ,
                              cl_uint           num_events_in_wait_list ,
                              const cl_event *  event_wait_list ,
                              cl_event *        event ){
  printf("clEnqueueAcquireEGLObjectsKHR\n");
  return tdispatch->clEnqueueAcquireEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueReleaseEGLObjectsKHR_wrap(cl_command_queue  command_queue ,
                              cl_uint           num_objects ,
                              const cl_mem *    mem_objects ,
                              cl_uint           num_events_in_wait_list ,
                              const cl_event *  event_wait_list ,
                              cl_event *        event ){
  printf("clEnqueueReleaseEGLObjectsKHR\n");
  return tdispatch->clEnqueueReleaseEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
}

static  cl_event 
clCreateEventFromEGLSyncKHR_wrap(cl_context       context ,
                            CLeglSyncKHR     sync ,
                            CLeglDisplayKHR  display ,
                            cl_int *         errcode_ret ){
  printf("clCreateEventFromEGLSyncKHR\n");
  return tdispatch->clCreateEventFromEGLSyncKHR(context, sync, display, errcode_ret);
}

static  cl_command_queue 
clCreateCommandQueueWithProperties_wrap(cl_context                context ,
                                   cl_device_id              device ,
                                   const cl_queue_properties *     properties ,
                                   cl_int *                  errcode_ret ){
  printf("clCreateCommandQueueWithProperties\n");
  return tdispatch->clCreateCommandQueueWithProperties(context, device, properties, errcode_ret);
}

static  cl_mem 
clCreatePipe_wrap(cl_context                  context ,
             cl_mem_flags                flags ,
             cl_uint                     pipe_packet_size ,
             cl_uint                     pipe_max_packets ,
             const cl_pipe_properties *  properties ,
             cl_int *                    errcode_ret ){
  printf("clCreatePipe\n");
  return tdispatch->clCreatePipe(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
}

static  cl_int 
clGetPipeInfo_wrap(cl_mem            pipe ,
              cl_pipe_info      param_name ,
              size_t            param_value_size ,
              void *            param_value ,
              size_t *          param_value_size_ret ){
  printf("clGetPipeInfo\n");
  return tdispatch->clGetPipeInfo(pipe, param_name, param_value_size, param_value, param_value_size_ret);
}

static  void * 
clSVMAlloc_wrap(cl_context        context ,
           cl_svm_mem_flags  flags ,
           size_t            size ,
           cl_uint           alignment ){
  printf("clSVMAlloc\n");
  return tdispatch->clSVMAlloc(context, flags, size, alignment);
}

static  void 
clSVMFree_wrap(cl_context         context ,
          void *             svm_pointer ){
  printf("clSVMFree\n");
  return tdispatch->clSVMFree(context, svm_pointer);
}

static  cl_int 
clEnqueueSVMFree_wrap(cl_command_queue   command_queue ,
                 cl_uint            num_svm_pointers ,
                 void *             svm_pointers[] ,
                 void (CL_CALLBACK * pfn_free_func)(cl_command_queue  queue ,
                                                        cl_uint           num_svm_pointers ,
                                                        void *            svm_pointers[] ,
                                                        void *            user_data ),
                 void *             user_data ,
                 cl_uint            num_events_in_wait_list ,
                 const cl_event *   event_wait_list ,
                 cl_event *         event ){
  printf("clEnqueueSVMFree\n");
  return tdispatch->clEnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueSVMMemcpy_wrap(cl_command_queue   command_queue ,
                   cl_bool            blocking_copy ,
                   void *             dst_ptr ,
                   const void *       src_ptr ,
                   size_t             size ,
                   cl_uint            num_events_in_wait_list ,
                   const cl_event *   event_wait_list ,
                   cl_event *         event ){
  printf("clEnqueueSVMMemcpy\n");
  return tdispatch->clEnqueueSVMMemcpy(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueSVMMemFill_wrap(cl_command_queue   command_queue ,
                    void *             svm_ptr ,
                    const void *       pattern ,
                    size_t             pattern_size ,
                    size_t             size ,
                    cl_uint            num_events_in_wait_list ,
                    const cl_event *   event_wait_list ,
                    cl_event *         event ){
  printf("clEnqueueSVMMemFill\n");
  return tdispatch->clEnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueSVMMap_wrap(cl_command_queue   command_queue ,
                cl_bool            blocking_map ,
                cl_map_flags       flags ,
                void *             svm_ptr ,
                size_t             size ,
                cl_uint            num_events_in_wait_list ,
                const cl_event *   event_wait_list ,
                cl_event *         event ){
  printf("clEnqueueSVMMap\n");
  return tdispatch->clEnqueueSVMMap(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clEnqueueSVMUnmap_wrap(cl_command_queue   command_queue ,
                  void *             svm_ptr ,
                  cl_uint            num_events_in_wait_list ,
                  const cl_event *   event_wait_list ,
                  cl_event *         event ){
  printf("clEnqueueSVMUnmap\n");
  return tdispatch->clEnqueueSVMUnmap(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
}

static  cl_sampler 
clCreateSamplerWithProperties_wrap(cl_context                      context ,
                              const cl_sampler_properties *   normalized_coords ,
                              cl_int *                        errcode_ret ){
  printf("clCreateSamplerWithProperties\n");
  return tdispatch->clCreateSamplerWithProperties(context, normalized_coords, errcode_ret);
}

static  cl_int 
clSetKernelArgSVMPointer_wrap(cl_kernel     kernel ,
                         cl_uint       arg_index ,
                         const void *  arg_value ){
  printf("clSetKernelArgSVMPointer\n");
  return tdispatch->clSetKernelArgSVMPointer(kernel, arg_index, arg_value);
}

static  cl_int 
clSetKernelExecInfo_wrap(cl_kernel             kernel ,
                    cl_kernel_exec_info   param_name ,
                    size_t                param_value_size ,
                    const void *          param_value ){
  printf("clSetKernelExecInfo\n");
  return tdispatch->clSetKernelExecInfo(kernel, param_name, param_value_size, param_value);
}

static  cl_int 
clGetKernelSubGroupInfoKHR_wrap(cl_kernel  in_kernel ,
                           cl_device_id in_device,
                           cl_kernel_sub_group_info  param_name ,
                           size_t input_value_size,
                           const void * input_value,
                           size_t param_value_size,
                           void* param_value,
                           size_t* param_value_size_ret ){
  printf("clGetKernelSubGroupInfoKHR\n");
  return tdispatch->clGetKernelSubGroupInfoKHR(in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
}

static  cl_kernel 
clCloneKernel_wrap(cl_kernel      source_kernel ,
              cl_int*        errcode_ret ){
  printf("clCloneKernel\n");
  return tdispatch->clCloneKernel(source_kernel, errcode_ret);
}

static  cl_program 
clCreateProgramWithIL_wrap(cl_context     context ,
                      const void*     il ,
                      size_t          length ,
                      cl_int*         errcode_ret ){
  printf("clCreateProgramWithIL\n");
  return tdispatch->clCreateProgramWithIL(context, il, length, errcode_ret);
}

static  cl_int 
clEnqueueSVMMigrateMem_wrap(cl_command_queue          command_queue ,
                       cl_uint                   num_svm_pointers ,
                       const void **             svm_pointers ,
                       const size_t *            sizes ,
                       cl_mem_migration_flags    flags ,
                       cl_uint                   num_events_in_wait_list ,
                       const cl_event *          event_wait_list ,
                       cl_event *                event ){
  printf("clEnqueueSVMMigrateMem\n");
  return tdispatch->clEnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, event);
}

static  cl_int 
clGetDeviceAndHostTimer_wrap(cl_device_id     device ,
                        cl_ulong*        device_timestamp ,
                        cl_ulong*        host_timestamp ){
  printf("clGetDeviceAndHostTimer\n");
  return tdispatch->clGetDeviceAndHostTimer(device, device_timestamp, host_timestamp);
}

static  cl_int 
clGetHostTimer_wrap(cl_device_id  device ,
               cl_ulong *    host_timestamp ){
  printf("clGetHostTimer\n");
  return tdispatch->clGetHostTimer(device, host_timestamp);
}

static  cl_int 
clGetKernelSubGroupInfo_wrap(cl_kernel                    kernel ,
                        cl_device_id                 device ,
                        cl_kernel_sub_group_info     param_name ,
                        size_t                       input_value_size ,
                        const void*                  input_value ,
                        size_t                       param_value_size ,
                        void*                        param_value ,
                        size_t*                      param_value_size_ret  ){
  printf("clGetKernelSubGroupInfo\n");
  return tdispatch->clGetKernelSubGroupInfo(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
}

static  cl_int 
clSetDefaultDeviceCommandQueue_wrap(cl_context            context ,
                               cl_device_id          device ,
                               cl_command_queue      command_queue ){
  printf("clSetDefaultDeviceCommandQueue\n");
  return tdispatch->clSetDefaultDeviceCommandQueue(context, device, command_queue);
}

static  cl_int 
clSetProgramReleaseCallback_wrap(cl_program           program ,
                            void (CL_CALLBACK *  pfn_notify )(cl_program  program , void *  user_data ),
                            void *               user_data ){
  printf("clSetProgramReleaseCallback\n");
  return tdispatch->clSetProgramReleaseCallback(program, pfn_notify, user_data);
}

static  cl_int 
clSetProgramSpecializationConstant_wrap(cl_program   program ,
                                   cl_uint      spec_id ,
                                   size_t       spec_size ,
                                   const void*  spec_value ){
  printf("clSetProgramSpecializationConstant\n");
  return tdispatch->clSetProgramSpecializationConstant(program, spec_id, spec_size, spec_value);
}

static  cl_mem 
clCreateBufferWithProperties_wrap(cl_context                 context ,
                             const cl_mem_properties *  properties ,
                             cl_mem_flags               flags ,
                             size_t                     size ,
                             void *                     host_ptr ,
                             cl_int *                   errcode_ret ){
  printf("clCreateBufferWithProperties\n");
  return tdispatch->clCreateBufferWithProperties(context, properties, flags, size, host_ptr, errcode_ret);
}

static  cl_mem 
clCreateImageWithProperties_wrap(cl_context                 context ,
                            const cl_mem_properties *  properties ,
                            cl_mem_flags               flags ,
                            const cl_image_format *    image_format ,
                            const cl_image_desc *      image_desc ,
                            void *                     host_ptr ,
                            cl_int *                   errcode_ret ){
  printf("clCreateImageWithProperties\n");
  return tdispatch->clCreateImageWithProperties(context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
}

static  cl_int 
clSetContextDestructorCallback_wrap(cl_context           context ,
                               void (CL_CALLBACK *  pfn_notify )(cl_context  context , void*  user_data ),
                               void *               user_data ){
  printf("clSetContextDestructorCallback\n");
  return tdispatch->clSetContextDestructorCallback(context, pfn_notify, user_data);
}

static void _init_dispatch(void) {
  dispatch.clGetPlatformIDs = &clGetPlatformIDs_wrap;
  dispatch.clGetPlatformInfo = &clGetPlatformInfo_wrap;
  dispatch.clGetDeviceIDs = &clGetDeviceIDs_wrap;
  dispatch.clGetDeviceInfo = &clGetDeviceInfo_wrap;
  dispatch.clCreateContext = &clCreateContext_wrap;
  dispatch.clCreateContextFromType = &clCreateContextFromType_wrap;
  dispatch.clRetainContext = &clRetainContext_wrap;
  dispatch.clReleaseContext = &clReleaseContext_wrap;
  dispatch.clGetContextInfo = &clGetContextInfo_wrap;
  dispatch.clCreateCommandQueue = &clCreateCommandQueue_wrap;
  dispatch.clRetainCommandQueue = &clRetainCommandQueue_wrap;
  dispatch.clReleaseCommandQueue = &clReleaseCommandQueue_wrap;
  dispatch.clGetCommandQueueInfo = &clGetCommandQueueInfo_wrap;
  dispatch.clSetCommandQueueProperty = &clSetCommandQueueProperty_wrap;
  dispatch.clCreateBuffer = &clCreateBuffer_wrap;
  dispatch.clCreateImage2D = &clCreateImage2D_wrap;
  dispatch.clCreateImage3D = &clCreateImage3D_wrap;
  dispatch.clRetainMemObject = &clRetainMemObject_wrap;
  dispatch.clReleaseMemObject = &clReleaseMemObject_wrap;
  dispatch.clGetSupportedImageFormats = &clGetSupportedImageFormats_wrap;
  dispatch.clGetMemObjectInfo = &clGetMemObjectInfo_wrap;
  dispatch.clGetImageInfo = &clGetImageInfo_wrap;
  dispatch.clCreateSampler = &clCreateSampler_wrap;
  dispatch.clRetainSampler = &clRetainSampler_wrap;
  dispatch.clReleaseSampler = &clReleaseSampler_wrap;
  dispatch.clGetSamplerInfo = &clGetSamplerInfo_wrap;
  dispatch.clCreateProgramWithSource = &clCreateProgramWithSource_wrap;
  dispatch.clCreateProgramWithBinary = &clCreateProgramWithBinary_wrap;
  dispatch.clRetainProgram = &clRetainProgram_wrap;
  dispatch.clReleaseProgram = &clReleaseProgram_wrap;
  dispatch.clBuildProgram = &clBuildProgram_wrap;
  dispatch.clUnloadCompiler = &clUnloadCompiler_wrap;
  dispatch.clGetProgramInfo = &clGetProgramInfo_wrap;
  dispatch.clGetProgramBuildInfo = &clGetProgramBuildInfo_wrap;
  dispatch.clCreateKernel = &clCreateKernel_wrap;
  dispatch.clCreateKernelsInProgram = &clCreateKernelsInProgram_wrap;
  dispatch.clRetainKernel = &clRetainKernel_wrap;
  dispatch.clReleaseKernel = &clReleaseKernel_wrap;
  dispatch.clSetKernelArg = &clSetKernelArg_wrap;
  dispatch.clGetKernelInfo = &clGetKernelInfo_wrap;
  dispatch.clGetKernelWorkGroupInfo = &clGetKernelWorkGroupInfo_wrap;
  dispatch.clWaitForEvents = &clWaitForEvents_wrap;
  dispatch.clGetEventInfo = &clGetEventInfo_wrap;
  dispatch.clRetainEvent = &clRetainEvent_wrap;
  dispatch.clReleaseEvent = &clReleaseEvent_wrap;
  dispatch.clGetEventProfilingInfo = &clGetEventProfilingInfo_wrap;
  dispatch.clFlush = &clFlush_wrap;
  dispatch.clFinish = &clFinish_wrap;
  dispatch.clEnqueueReadBuffer = &clEnqueueReadBuffer_wrap;
  dispatch.clEnqueueWriteBuffer = &clEnqueueWriteBuffer_wrap;
  dispatch.clEnqueueCopyBuffer = &clEnqueueCopyBuffer_wrap;
  dispatch.clEnqueueReadImage = &clEnqueueReadImage_wrap;
  dispatch.clEnqueueWriteImage = &clEnqueueWriteImage_wrap;
  dispatch.clEnqueueCopyImage = &clEnqueueCopyImage_wrap;
  dispatch.clEnqueueCopyImageToBuffer = &clEnqueueCopyImageToBuffer_wrap;
  dispatch.clEnqueueCopyBufferToImage = &clEnqueueCopyBufferToImage_wrap;
  dispatch.clEnqueueMapBuffer = &clEnqueueMapBuffer_wrap;
  dispatch.clEnqueueMapImage = &clEnqueueMapImage_wrap;
  dispatch.clEnqueueUnmapMemObject = &clEnqueueUnmapMemObject_wrap;
  dispatch.clEnqueueNDRangeKernel = &clEnqueueNDRangeKernel_wrap;
  dispatch.clEnqueueTask = &clEnqueueTask_wrap;
  dispatch.clEnqueueNativeKernel = &clEnqueueNativeKernel_wrap;
  dispatch.clEnqueueMarker = &clEnqueueMarker_wrap;
  dispatch.clEnqueueWaitForEvents = &clEnqueueWaitForEvents_wrap;
  dispatch.clEnqueueBarrier = &clEnqueueBarrier_wrap;
  dispatch.clGetExtensionFunctionAddress = &clGetExtensionFunctionAddress_wrap;
  dispatch.clCreateFromGLBuffer = &clCreateFromGLBuffer_wrap;
  dispatch.clCreateFromGLTexture2D = &clCreateFromGLTexture2D_wrap;
  dispatch.clCreateFromGLTexture3D = &clCreateFromGLTexture3D_wrap;
  dispatch.clCreateFromGLRenderbuffer = &clCreateFromGLRenderbuffer_wrap;
  dispatch.clGetGLObjectInfo = &clGetGLObjectInfo_wrap;
  dispatch.clGetGLTextureInfo = &clGetGLTextureInfo_wrap;
  dispatch.clEnqueueAcquireGLObjects = &clEnqueueAcquireGLObjects_wrap;
  dispatch.clEnqueueReleaseGLObjects = &clEnqueueReleaseGLObjects_wrap;
  dispatch.clGetGLContextInfoKHR = &clGetGLContextInfoKHR_wrap;
  dispatch.clSetEventCallback = &clSetEventCallback_wrap;
  dispatch.clCreateSubBuffer = &clCreateSubBuffer_wrap;
  dispatch.clSetMemObjectDestructorCallback = &clSetMemObjectDestructorCallback_wrap;
  dispatch.clCreateUserEvent = &clCreateUserEvent_wrap;
  dispatch.clSetUserEventStatus = &clSetUserEventStatus_wrap;
  dispatch.clEnqueueReadBufferRect = &clEnqueueReadBufferRect_wrap;
  dispatch.clEnqueueWriteBufferRect = &clEnqueueWriteBufferRect_wrap;
  dispatch.clEnqueueCopyBufferRect = &clEnqueueCopyBufferRect_wrap;
  dispatch.clCreateSubDevicesEXT = &clCreateSubDevicesEXT_wrap;
  dispatch.clRetainDeviceEXT = &clRetainDeviceEXT_wrap;
  dispatch.clReleaseDeviceEXT = &clReleaseDeviceEXT_wrap;
  dispatch.clCreateEventFromGLsyncKHR = &clCreateEventFromGLsyncKHR_wrap;
  dispatch.clCreateSubDevices = &clCreateSubDevices_wrap;
  dispatch.clRetainDevice = &clRetainDevice_wrap;
  dispatch.clReleaseDevice = &clReleaseDevice_wrap;
  dispatch.clCreateImage = &clCreateImage_wrap;
  dispatch.clCreateProgramWithBuiltInKernels = &clCreateProgramWithBuiltInKernels_wrap;
  dispatch.clCompileProgram = &clCompileProgram_wrap;
  dispatch.clLinkProgram = &clLinkProgram_wrap;
  dispatch.clUnloadPlatformCompiler = &clUnloadPlatformCompiler_wrap;
  dispatch.clGetKernelArgInfo = &clGetKernelArgInfo_wrap;
  dispatch.clEnqueueFillBuffer = &clEnqueueFillBuffer_wrap;
  dispatch.clEnqueueFillImage = &clEnqueueFillImage_wrap;
  dispatch.clEnqueueMigrateMemObjects = &clEnqueueMigrateMemObjects_wrap;
  dispatch.clEnqueueMarkerWithWaitList = &clEnqueueMarkerWithWaitList_wrap;
  dispatch.clEnqueueBarrierWithWaitList = &clEnqueueBarrierWithWaitList_wrap;
  dispatch.clGetExtensionFunctionAddressForPlatform = &clGetExtensionFunctionAddressForPlatform_wrap;
  dispatch.clCreateFromGLTexture = &clCreateFromGLTexture_wrap;
  dispatch.clCreateFromEGLImageKHR = &clCreateFromEGLImageKHR_wrap;
  dispatch.clEnqueueAcquireEGLObjectsKHR = &clEnqueueAcquireEGLObjectsKHR_wrap;
  dispatch.clEnqueueReleaseEGLObjectsKHR = &clEnqueueReleaseEGLObjectsKHR_wrap;
  dispatch.clCreateEventFromEGLSyncKHR = &clCreateEventFromEGLSyncKHR_wrap;
  dispatch.clCreateCommandQueueWithProperties = &clCreateCommandQueueWithProperties_wrap;
  dispatch.clCreatePipe = &clCreatePipe_wrap;
  dispatch.clGetPipeInfo = &clGetPipeInfo_wrap;
  dispatch.clSVMAlloc = &clSVMAlloc_wrap;
  dispatch.clSVMFree = &clSVMFree_wrap;
  dispatch.clEnqueueSVMFree = &clEnqueueSVMFree_wrap;
  dispatch.clEnqueueSVMMemcpy = &clEnqueueSVMMemcpy_wrap;
  dispatch.clEnqueueSVMMemFill = &clEnqueueSVMMemFill_wrap;
  dispatch.clEnqueueSVMMap = &clEnqueueSVMMap_wrap;
  dispatch.clEnqueueSVMUnmap = &clEnqueueSVMUnmap_wrap;
  dispatch.clCreateSamplerWithProperties = &clCreateSamplerWithProperties_wrap;
  dispatch.clSetKernelArgSVMPointer = &clSetKernelArgSVMPointer_wrap;
  dispatch.clSetKernelExecInfo = &clSetKernelExecInfo_wrap;
  dispatch.clGetKernelSubGroupInfoKHR = &clGetKernelSubGroupInfoKHR_wrap;
  dispatch.clCloneKernel = &clCloneKernel_wrap;
  dispatch.clCreateProgramWithIL = &clCreateProgramWithIL_wrap;
  dispatch.clEnqueueSVMMigrateMem = &clEnqueueSVMMigrateMem_wrap;
  dispatch.clGetDeviceAndHostTimer = &clGetDeviceAndHostTimer_wrap;
  dispatch.clGetHostTimer = &clGetHostTimer_wrap;
  dispatch.clGetKernelSubGroupInfo = &clGetKernelSubGroupInfo_wrap;
  dispatch.clSetDefaultDeviceCommandQueue = &clSetDefaultDeviceCommandQueue_wrap;
  dispatch.clSetProgramReleaseCallback = &clSetProgramReleaseCallback_wrap;
  dispatch.clSetProgramSpecializationConstant = &clSetProgramSpecializationConstant_wrap;
  dispatch.clCreateBufferWithProperties = &clCreateBufferWithProperties_wrap;
  dispatch.clCreateImageWithProperties = &clCreateImageWithProperties_wrap;
  dispatch.clSetContextDestructorCallback = &clSetContextDestructorCallback_wrap;
}
